<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_22) on Fri Jan 28 01:51:32 EST 2011 -->
<TITLE>
StructuredProperties (StructuredProperties Configuration)
</TITLE>

<META NAME="date" CONTENT="2011-01-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="StructuredProperties (StructuredProperties Configuration)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../net/stupendous/util/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/StructuredProperties.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../net/stupendous/util/StructuredPropertiesSymbol.html" title="class in net.stupendous.util"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/stupendous/util/StructuredProperties.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="StructuredProperties.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.stupendous.util</FONT>
<BR>
Class StructuredProperties</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>net.stupendous.util.StructuredProperties</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>StructuredProperties</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
StructuredProperties is a Domain Specific Language for structured
 configuration properties files.
 
 <p>
 A Structured Properties .conf file looks something like this:
 <pre>
   identifier = value
   
   identifier {              # HashMap 
     identifier = value
     identifier = value
   }
   
   identifier {              # ArrayList
     value
     value
   }
 </pre>
 <p>
 Where values are either quoted strings, numbers or a block. The only
 restriction with blocks is that you need to omit the = after an
 identifier in a HashMap.
 <p>
 Comments are simply # until the end of line.
 <p>
 The Lexer was built using JFlex, so should be fairly robust. I had a
 stab at using Cup but it seemed beyond me to grok how to make it fly at
 the time so I hand wrote the Parser. It seems to work well, though I
 need more test cases.
 <p>
 <b>Why do we need another configuration file format?</b>
 <p>
 Back in the dawn of history, Java was invented and along with it XML
 came into fashion for storing structured configuration information.
 <p>
 Property lists were never in fashion, as while you could structure data
 with it by separating identifiers with a period, it was ugly and nobody
 liked it. They preferred XML.
 <p>
 But the winds of change blew and people came to realise that using XML
 is a really fucking stupid idea, because it quickly becomes too hard to
 read or edit. Especially edit. Half the time, people that were trying to
 edit it just wanted a simple webserver to work, or wanted to store some
 simple data, yet XML demanded that they use attributes and keep tags
 balanced, etc.
 <p>
 At some point in recent history, people that were realising that making
 humans edit XML files, sought out a better file format they could abuse
 into being a config file format. So, many turned to JSON, or worse, YAML.
 <p>
 "But YAML is so easy to edit! Look at JSON! It's a subset, and its even
 easier!"
 <p>
 Easier yes, but ideal for humans? No. Look at a JSON string that encodes a Map:
 <p>
 <pre>
 {
   "balance":1000.21,
   "num":100,
   "nickname":null,
   "is_vip":true,
   "name":"foo" 
 }
 </pre>
 <p>
 Now compare this to a StructuredProperties config string:
 <p>
 <pre>
 { 
   balance = 1000.21 
   num = 100 
   nickname = 0 
   is_vip = true 
   name = foo 
 }
 </pre>
 <p>
 Note that the keys are not required to be quoted. If you need an exotic key, you
 just surround it with double quotes. All values are strings; its up to you to
 convert them when you read them into whatever objects you need.
 <p>
 Whitespace separates items, as there is no need for anything to separate
 them. Likewise I could have chosen not to have an "=" between the key and value
 but it was decided that it would be nice to have some kind of visual similarity
 to Java Properties files.
 <p>
 If you want a good data exchange format, look at JSON or YAML or XML. Thats
 what they are designed to do really well. Editing files in these formats by
 hand is possible, sure, but it's just a byproduct of their goals. It's not goal
 of any of these languages to be used as configuration files, nor is it their goal
 to be easily edited by humans.
 <p>
 The core goals of StructuredProperties is to be
 <p>
   <li>Easily readable by humans</li>
   <li>Easily understandable by humans</li>
   <li>Easily editable by humans</li>
 <p>
 Note that one of the core goals is not "to be able to represent every possible
 data type in existence". This is because there are many languages out there
 already that do a far better job at doing that. My suggestion is that if you
 have a requirement for a configuration file that stores some exotic data, that
 you store the exotic data in XML or JSON files with the rest of your configuration
 in a Structured Properties configuration file.
 <p>
 <b>Structured Properties Grammar</b><p>
 <p>
 A Structured Properties Configuration file (*.conf) is a simple human
 readable and human editible configuration file format with a syntax 
 that can be understood easily by anyone by just looking at the file.
<p>
 Because conf files only support primitive types, the syntax can be kept
 clean, and syntax errors in the configuration file can be kept to a
 minimum. If you need more complex types, those objects probably should
 belong in other serialization formats, and they probably are not required
 to be human editable.
<p>
 This example file contains a detailed explanation of the syntax of this
 file, but the structure and usage of a Structured Properties file
 is intended to be natural and easy to pick up without reading
 documentation.
<p>
 <b>COMMENT</b>
<p>
   # This is a comment. The only way to start a comment is with #, C-style 
   comments are not supported.
<p>
   Comments may be anywhere you like and are ignored until end of line.
<p>
 <b>WHITESPACE</b>
<p>
   Whitespace is unimportant to the lexer and parser.
<p>
   There is no particular level of indentation required nor does indentation
   affect the parser in any way.
<p>
   The only explicit exception to this is when you use unquoted strings,
   explained below.
<p>
   Whitespace is defined as being a space ' ', a tab '\t' or a line ending
   character '\r' & '\n'. Vertical tab '\v' and line feed '\f' are also
   treated as whitespace, but you should avoid using them anyway.
<p>
 <b>CHARACTER SET</b>
<p>
   Structured Property Configuration files are UTF-8. UTF-8 is the only
   supported character set.
<p>
 <b>KEY STRINGS</b>
<p>
   Key strings are used as unquoted string keys in HASHMAPS.
<p>
   Key strings may be a bare word alphanumeric string that must begin with 
   a letter, and can contain '-' and '_'.
<p>
   Syntax examples:
<pre>
     something-name some5thing6 something_else
</pre>
   You can also use a QUOTED STRING as a key, in which case all characters
   are valid. Be aware that using a QUOTED STRING with a '.' will cause the
   convenience method getProperty(String) to fail; you will need to use
   getProperty(...) and specify each component explicitly.
<p>
 <b>UNQUOTED STRING</b>
<p>
   Unquoted strings start from the first valid non whitespace character and
   end at the last. Unquoted strings may be continued onto the next line
   using a backslash (\) character, in the same way as Property files.
   Whitespace before the backslash is preserved, so that you can concatenate
   multiple strings easily.
<p>
   When an unquoted string is continued, the whitespace leading up to the
   first non whitespace character on the new line is ignored, at which pint
   the string is then continued.
<p>
   Tab (\t) and newline (\r and \n) escape characters are supported.
   The closed brace '}' is unsupported as a part of an unquoted string. If 
   you need a closed brace, use a quoted string.
 <p>
   EXAMPLE
<pre>
      some_key = This is an unquoted string. \
                 This part of the string continues on.
</pre>
<p>   
 <b>QUOTED STRINGS</b>
<p>
   Quoted strings are started with a doublequote (") and ended with a
   doublequote. There is no way to continue a quoted string; either use an
   unquoted string, or let the line run on.
<p>
   Tab (\t) and newline (\r and \n) escape characters are supported.
<p>
   Quoted strings may be used in HASHMAPs and ARRAYLISTs as both keys and
   values.
<p>
   EXAMPLE
<pre> 
      "This is a quoted string"
</pre>
<p>
 <b>BLOCKS</b>
<p>
   A block is designated with a '{' and ended with a '}'. If a block is used
   as the value in a HASHMAP, you may omit the '='.
<p>
   A block can designate the beginning of either a HASHMAP or an ARRAYLIST. 
   The type it is depends on the symbols after the open brace '{'. If the
   two symbols are "STRING =", then it's a HASHMAP.
<p>
   A "STRING STRING ..." would designate an ARRAYLIST, where as a single
   STRING would also designate an ARRAYLIST.
<p>
   It goes without saying that all items in a HASHMAP must be STRING = 
   VALUE items, while all items in an ARRAYLIST must just be STRINGs.
<p>
 <b>HASHMAP</b>
<p>
   HashMaps are used to provide a simple way to define key/value information.
   HashMaps are converted to java.util.HashMap objects by the parser.
<p>
   Syntax:
<pre>
     { KEY = VALUE
       KEY = VALUE 
       KEY = VALUE 
       ... }
</pre>
   Whitespace between the '=' and the key and value is not required, but 
   should be included for readability. If you use quoted strings for the
   values, then you only need whitespace between each entry.
<p>
   If you want to use unquoted strings, as they go until the end of line, you
   will need each key/value pair on a new line.
<p>
   The entire configuration file has an implied { } around it, and is forced
   to being a HashMap. Therefore, all entries in the root of the file is
   required to be a KEY = VALUE entry.
<p>
 <b>ARRAYLIST</b>
<p>
   ArrayLists are used to provide a way to define a list of values. ArrayLists
   are converted to java.util.ArrayList objects by the parser.
<p>
   Syntax:
<pre> 
     { VALUE 
       VALUE 
       VALUE 
       ... }
</pre> 
   As with HashMaps, using unquoted strings will require newlines between
   entries, while using quoted strings do not.
   <p>
   For complete examples of the syntax, examine the example.conf file on github.
<p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Nathan Ollerenshaw</DD>
</DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#StructuredProperties(java.io.File)">StructuredProperties</A></B>(java.io.File&nbsp;configFile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the File as a Structured Properties configuration file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#StructuredProperties(java.io.InputStream)">StructuredProperties</A></B>(java.io.InputStream&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the InputStream as a Structured Properties configuration file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#StructuredProperties(java.io.Reader)">StructuredProperties</A></B>(java.io.Reader&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the Reader as a Structured Properties configuration file.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#getProperty(java.lang.String...)">getProperty</A></B>(java.lang.String...&nbsp;keyparts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extracts a given object/string at a path that is provided as separate
 arguments to the method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#getProperty(java.lang.String, java.lang.String)">getProperty</A></B>(java.lang.String&nbsp;defaultValue,
            java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a given property at the path indicated by the string key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashMap&lt;java.lang.String,java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#getRoot()">getRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#isDebugging()">isDebugging</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether or not the StructuredProperties parser will emit
 debugging information to stderr.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#load(java.io.InputStream)">load</A></B>(java.io.InputStream&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please see load(java.io.Reader reader);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#load(java.io.Reader)">load</A></B>(java.io.Reader&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method (as well as the constructors and the other load methods) loads
 and parses a Structured Properties Configuration file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple test harness; provide the name of a config file as
 an argument, and it will parse the file and output the root object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/stupendous/util/StructuredProperties.html#setDebugging(boolean)">setDebugging</A></B>(boolean&nbsp;debuging)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables the debugging mode of the StructuredProperties
 class.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="StructuredProperties(java.io.File)"><!-- --></A><H3>
StructuredProperties</H3>
<PRE>
public <B>StructuredProperties</B>(java.io.File&nbsp;configFile)
                     throws java.lang.Error</PRE>
<DL>
<DD>Parses the File as a Structured Properties configuration file.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>configFile</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.lang.Error</CODE></DL>
</DL>
<HR>

<A NAME="StructuredProperties(java.io.Reader)"><!-- --></A><H3>
StructuredProperties</H3>
<PRE>
public <B>StructuredProperties</B>(java.io.Reader&nbsp;in)
                     throws java.lang.Error</PRE>
<DL>
<DD>Parses the Reader as a Structured Properties configuration file.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.lang.Error</CODE></DL>
</DL>
<HR>

<A NAME="StructuredProperties(java.io.InputStream)"><!-- --></A><H3>
StructuredProperties</H3>
<PRE>
public <B>StructuredProperties</B>(java.io.InputStream&nbsp;in)
                     throws java.lang.Error</PRE>
<DL>
<DD>Parses the InputStream as a Structured Properties configuration file.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.lang.Error</CODE></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="isDebugging()"><!-- --></A><H3>
isDebugging</H3>
<PRE>
public static boolean <B>isDebugging</B>()</PRE>
<DL>
<DD>Determine whether or not the StructuredProperties parser will emit
 debugging information to stderr.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>boolean</DL>
</DD>
</DL>
<HR>

<A NAME="setDebugging(boolean)"><!-- --></A><H3>
setDebugging</H3>
<PRE>
public static void <B>setDebugging</B>(boolean&nbsp;debuging)</PRE>
<DL>
<DD>Enables or disables the debugging mode of the StructuredProperties
 class. This is a static variable, so it will affect all instances
 of the class.
 
 Typically you wil do this if you want to verify the parser is parsing
 files correctly. It has little use other than to someone working with
 the internals of the parser.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>debuging</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)</PRE>
<DL>
<DD>A simple test harness; provide the name of a config file as
 an argument, and it will parse the file and output the root object.
 <p>
 Java will handily iterate through ArrayLists and HashMaps if it finds
 them, as it calls toString() on everything it's listing, so it
 prints a (badly formatted) representation of whats in your configuration.
 <p>
 java -jar StructuredProperties.jar <filename>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>args</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="getProperty(java.lang.String, java.lang.String)"><!-- --></A><H3>
getProperty</H3>
<PRE>
public java.lang.Object <B>getProperty</B>(java.lang.String&nbsp;defaultValue,
                                    java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Returns a given property at the path indicated by the string key.
 <p>
 Key is a path to a hashMap entry. If you want to get a specific
 entry in an a array, get the ArrayList itself first.
 <p>
 example:
 <p>
 <pre>
 c.getProperty("default.options.server.ip-address", "12.0.0.1");
 </pre>
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>defaultValue</CODE> - 
<DT><B>Returns:</B><DD>HashMap, ArrayList, String</DL>
</DD>
</DL>
<HR>

<A NAME="getProperty(java.lang.String...)"><!-- --></A><H3>
getProperty</H3>
<PRE>
public java.lang.Object <B>getProperty</B>(java.lang.String...&nbsp;keyparts)</PRE>
<DL>
<DD>Extracts a given object/string at a path that is provided as separate
 arguments to the method. This is the only way to get at a configuration
 object if you've decided that you want to use "." in a quoted string
 key.
 <p>
 example:
 <p>
 <pre>
 c.getProperty("default", "options", "server", "ip-address");
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>defaultValue</CODE> - <DD><CODE>keyparts</CODE> - 
<DT><B>Returns:</B><DD>HashMap, ArrayList, String</DL>
</DD>
</DL>
<HR>

<A NAME="load(java.io.Reader)"><!-- --></A><H3>
load</H3>
<PRE>
public void <B>load</B>(java.io.Reader&nbsp;reader)</PRE>
<DL>
<DD>This method (as well as the constructors and the other load methods) loads
 and parses a Structured Properties Configuration file.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.lang.Error</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="load(java.io.InputStream)"><!-- --></A><H3>
load</H3>
<PRE>
public void <B>load</B>(java.io.InputStream&nbsp;in)
          throws java.lang.Error</PRE>
<DL>
<DD>Please see load(java.io.Reader reader);
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.lang.Error</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getRoot()"><!-- --></A><H3>
getRoot</H3>
<PRE>
public java.util.HashMap&lt;java.lang.String,java.lang.Object&gt; <B>getRoot</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../net/stupendous/util/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/StructuredProperties.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../net/stupendous/util/StructuredPropertiesSymbol.html" title="class in net.stupendous.util"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/stupendous/util/StructuredProperties.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="StructuredProperties.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2011 Nathan Ollerenshaw. All Rights Reserved.</i>
</BODY>
</HTML>
